case 1:
-------
> hi cat file2 file3

case 2:
------
ls > green.txt > blue.txt < blue.txt
cat trash | grep =          it hangs, I believe it's the forensic is the cause
case 3:
--------
minishell $> chmod -w green.txt 
minishell $> ls > green.txt    ls shouldn't execute
econvert cmd not found to 127
file not found exit code 1

case 4:
-------
Mem clean

case 5:  (Bilal)
-------
ctr c twice shouldn't exit 
cat <<hello | cat << green  should do the heredoc before execution
cat << hello    then CTR C doesn't execute
cat << hello    then CTR D execute
cat + ctr D or + ctr c

(solved)
-------------------------------------------------------------------------
case 1:
-------
cd error

export a#=3

minishell $> echo ""$PWD   bug with the start location of the first qoute, is 5, should be 6
minishell: syntax error near unexpected token 

minishell $> unset PWD
minishell $> unset HOME
minishell $> cd       
[1]    218 segmentation fault  ./minishell 
minishell $> ll | ll | ll
cat <<hello <<hello
minishell $> "l"s            should execute ls
ls: cannot access '': No such file or directory 
case 4:
-------
clean export error messages
export > file      shouldn't print

case 1 : soloution, modify the exec_exit to take argument right from t and check for numebrs
-------
exit 5   let the exit take arguments
exit add arguments

./minishell any / consider as absoulte path

case 7:
------
minishell $> /dsfsdf
execve: No such file or directory
minishell $> echo $?
0
remember to set the exit code (1) later inshalla

case 3:
-------
to lower for cmd

case 1:
--------
CMD more than max number of allowed char
c

ase 2:
------
mkdir abc
minishell $> cd abc
bash: cd: abc: No such file or directory
cd green.txt  SHOULD THROW AN ERROR
cd: string not in pwd: /Users/ahsalem (delete this error message )

case 1:
------
quotes should be deleted
//this case is handled by changing the flag in the cmdsmasher
echo l"s"       should print ls
echo a="ls"		should print a=ls
a="ls"		should taken as  a=ls
"ls"""          should execute ls
where the **** have a disappeared, also quotes should be deleted too
echo a='ls'     should give a='ls'
='ls

minishell $> export R#R@#R
minishell: export: `R#R@#R': not a valid identifier
remember to set the exit code (1) later inshalla


case 2:
-------
export a="ls    -la"
ls -la should be considered as new command and being parsed accordingly
echo "lssl"sss
inishell $> export a="ls -la"
minishell $> $a
minishell: ls -la: command not found
minishell $>